#!/usr/bin/env python3
# editor width: 100   -----------------------------------------------------------------------------

###  wyng-util-qubes
###  Copyright Christopher Laprise 2023 / tasket@protonmail.com
###  Licensed under GNU General Public License v3. See file 'LICENSE'.

print("wyng-util-qubes v0.8wip rel 20240404")

import qubesadmin, sys, os, shutil, subprocess, argparse, json
from qubesadmin.backup.core3 import Core3Qubes

exists  = os.path.exists

def b2i(b):   return int.from_bytes(b, byteorder="big")

def err_out(text):   sys.stderr.write(text+"\n")

# Exit with simple message
def x_it(code, text):
    err_out("Error: "+text)
    #cleanup()
    shutil.rmtree(tmpdir, ignore_errors=True)
    sys.exit(code)


class QubesPool:
    def __init__(self, qobj, path):
        self.name = qobj.name    ; self.driver = qobj.driver    ; self.config = qobj.config
        self.path = path         ; self.qobj   = qobj


# Get Qubes storage pools
def get_pools():
    pools = {}
    for qpool in qadmin.pools.values():
        if qpool.driver == "lvm_thin":
            path = (qpool.config['volume_group'], qpool.config['thin_pool'])
        elif qpool.driver == "file-reflink":
            path = (qpool.config["dir_path"], )
        else:
            continue
        pools[qpool.name] = QubesPool(qpool, path)
    return pools


def print_pools():
    print("\nQubes local storage pools:")
    for pname, pool in qpools_d.items():
        print(f" {pool.name:<24}: {pool.driver:<12}, {pool.path}")


# Get archive directory
def get_wyng_directory():
    # Parse full vol/session list into lookup tables...
    # wvolsessionmap:  session -> volume_name
    # wsessionqubes :  session -> qube_name
    # wvolumemap    :  volume_name -> session
    # qube_wvolmap  :  (dict)qube_name -> (dict)session -> (set)volume_suffix ('root' or 'private')

    wvolsessionmap, wvolumemap, qube_wvolmap = {}, {}, {}   ; volname = qubename = None
    wyng_cmd = w_options + ["--json", "list"]
    jdata = json.loads((j := run(wyng_cmd, text=True).stdout)[j.find("{"):])

    for volname, sname in ((vk,sk) for vk,vv in jdata["volumes"].items() for sk in vv["sessions"]):
        wvolumemap.setdefault(volname, list()).append(sname[2:])
        wvolsessionmap.setdefault(sname[2:], set()).add(volname)

    wsessionqubes = {}
    for ses,vols in wvolsessionmap.items():
        if s := set((get_qubename_parts(x)[1] for x in vols
                     if x.endswith(("-root","-private","/root.img","/private.img")))):
            wsessionqubes[ses] = s

    # make qube_wvolmap...
    for vol, ses in ((x,s) for x,y in wvolumemap.items() for s in y 
                     if x.startswith(("vm-","appvms/","vm-templates/"))):
        prefix, qubename, suffix = get_qubename_parts(vol)
        qube_wvolmap.setdefault(qubename, dict()).setdefault(ses, set()).add(suffix)

    return jdata, wvolsessionmap, wvolumemap, wsessionqubes, qube_wvolmap


def get_qubes_metadata(session):
    # Receive metadata
    wyng_cmd = w_options + ["-u", "--quiet",
                            "--save-to="+tarpath, "--session="+session, "receive", mvolname]
    result = run(wyng_cmd, check=True)

    #Enh: get archive listing and check volume presence vs selected qube list
    result = run(["tar", "-xzf", tarpath], cwd=tmpdir, check=True)
    return Core3Qubes(tmpdir+"/"+qubesxml).domains


def get_vm_volname(vm, voltype="private"):
    assert voltype in ("private","root")
    vol = vm.volumes[voltype]
    pt  = qpools_d[vol.pool].driver    ; template = vm.klass == "TemplateVM"

    if pt == "file-reflink":
        #vname = f'{"vm-templates" if template else "appvms"}/{vm.name}/{voltype}.img'
        vname = vm.volumes[voltype].vid + ".img"
    elif pt == "lvm_thin": #### or (pt == "file-reflink" and convert):
        vname = f"vm-{vm.name}-{voltype}"
    return vname


def get_qubename_parts(n):
    if n.startswith("vm-") and n.endswith(("-root","-private")):
        return ["vm"] + n.partition("vm-")[-1].rsplit("-",maxsplit=1)
    elif n.startswith(("appvms/","vm-templates/")) and n.endswith(("/root.img","/private.img")):
        return ((t := n.split("/"))[0], "/".join(t[1:-1]), t[-1])
    else:
        return "","",""


def convert_volname(n, to_pooltype, template):
    p = get_qubename_parts(n)
    if to_pooltype == "file-reflink":
        assert n.startswith("vm-")
        n = f'{"vm-templates" if template else "appvms"}/{p[1]}/{p[2].removesuffix(".img")}.img'
    elif to_pooltype == "lvm_thin":
        assert n.startswith("vm-templates") or not template
        n = f'vm-{p[1]}-{p[2].removesuffix(".img")}'
    return (n, template, to_pooltype)


def handle_wyng_vol_error(p):
    errln = [x.partition("volumes(s)") for x in p.stdout.splitlines() if "volumes(s):" in x]
    err_domains.extend(errln.split())
    err_out("(Wyng) "+"".join(errln))


def run(cmd, check=True, **kwargs):
    capt   = not ("stderr" in kwargs or "stout" in kwargs)
    result = subprocess.run(cmd, capture_output=capt, **kwargs)
    if check and result.returncode:
        err_out(f"{result.stdout}\n{result.stderr}")
        sys.exit(result.returncode)
    return result



##  MAIN  ##

if sys.hexversion < 0x3080000:
    err_out("Python ver. 3.8 or greater required."); sys.exit(1)

# Root user required
if os.getuid() > 0:
    err_out("Must be root user."); sys.exit(1)


# Parse Arguments

parser = argparse.ArgumentParser(description="")
parser.add_argument("action", choices=("backup","restore","verify","prune","delete","list"),
                    help="Action to take")
parser.add_argument("--authmin", default="5", help="Minutes to remember authentication.")
parser.add_argument("--session", help="YYYYMMDD-HHMMSS[,YYYYMMDD-HHMMSS]"
                                 " select session date, singular or range.")
parser.add_argument("--dedup", "-d", action="store_true", default=False,
                    help="Data deduplication. (backup)")
parser.add_argument("--includes", "-i", action="store_true", default=False,
                    help="Select VMs marked 'include in backups' (backup)")
parser.add_argument("--exclude", action="append", default=[],
                    help="VM name to exclude. (backup)")
parser.add_argument("--volume", action="append", default=[],
                    help="Extra logical volume to include.")
parser.add_argument("--autoprune", default=None,
                    help="Automatic pruning: off/on/full. (backup, prune)")
parser.add_argument("--all-before", dest="allbefore", action="store_true", default=False,
                    help="Select all sessions before --session date-time.")
parser.add_argument("--pool-info", action="store_true", default=False,
                    help="Show local disk storage (list)")
parser.add_argument("--pool", "-p", default=None,
                    help="Override default 'vm-pool' Qubes local storage pool.")
parser.add_argument("--local", help="Deprecated: Use --pool")
parser.add_argument("--dest",  help="URL location of archive.")
parser.add_argument("-w", dest="wyngopt", action="append", default=[],
                    help="Pass an option to Wyng directly.")
parser.add_argument("--unattended", "-u", action="store_true", default=False,
                    help="Unattended operation")
parser.add_argument("--meta-dir", dest="metadir", default="", help="Use alternate metadata path.")
parser.add_argument("qubenames", nargs="*")
options = parser.parse_args()    ; options.action = options.action.lower()
options.unattended = options.unattended or not sys.stdin.isatty()

if options.volume:   x_it("--volume not implemented.")



## CONSTANTS / GLOBALS ##

thispath   = os.path.dirname(__file__) ; mvolname   = "wyng-qubes-metadata"
wyngcmd    = thispath+"/wyng" if exists(thispath+"/wyng") else "wyng"
tmpdir     = "/tmp/wyng-util-qubes"    ; tarpath    = tmpdir+"/qmeta.tgz"
qubesvar   = "/var/lib/qubes/"         ; qubesxml   = "qubes.xml"    ; fwfile = "firewall.xml"
qadmin     = qubesadmin.Qubes()        ; qdaemon    = qadmin.app     ; live_qubes = qdaemon.domains
selected   = options.qubenames         ; err_domains= []

if os.path.exists(tmpdir):   shutil.rmtree(tmpdir)
os.makedirs(tmpdir)

w_options = [wyngcmd]    ; qpools_d  = get_pools()
if options.dest:
    w_options.append("--dest="+options.dest)
else:
    x_it(1, "A --dest <archive location> is required.")
if options.local:   x_it(1, "Please use --pool instead of --local")
if options.metadir:    w_options.append("--meta-dir="+options.metadir)
if options.unattended: w_options.append("-u")
w_options.append("--authmin="+options.authmin)
w_options.extend(["--"+x for x in options.wyngopt])


if not (options.action == "list" and options.pool_info):
    arch_mdata, wvolsessionmap, wvolumemap, wsessionqubes, qube_wvolmap = get_wyng_directory()


# Process Actions
if options.action == "backup":

    vols     = []
    includes = [x.name for x in live_qubes if x.include_in_backups and options.includes]
    for vmname in sorted(set(selected+includes)):
        if vmname == "dom0" or vmname not in live_qubes or vmname in options.exclude:
            print("Skipping", vmname)
            continue
        vm = live_qubes[vmname]
        for ii in ("private","root"):
            if ii == "root" and vm.klass not in ("TemplateVM","StandaloneVM"):   continue
            # Create a 3-tuple of volume obj, normalized vol name, pool obj
            vols.append( (vm.volumes[ii], get_vm_volname(vm, ii), qpools_d[vm.volumes[ii].pool]) )

    if not vols:   x_it(1, "Please supply a list of Qubes VMs to backup.")

    # Copy the Qubes metadata to a .tar
    os.chdir(qubesvar)
    run("find . -name '*.xml' | tar -czf " +tarpath+ " --verbatim-files-from -T -", shell=True)

    # Find unique local paths / vgs
    sources = {(x[2].driver, x[2].path[0]): x[2] for x in vols}
    if len(sources) > 1:  x_it(1, "Not Implemented: Multiple --local sources.")

    volnames = [x[1] for x in vols]
    qpool    = list(sources.values())[0]

    # Start Wyng backup with selected VM volumes and import of the metadata tar
    w_options.append("--local=" + "/".join(qpool.path))
    wyng_cmd = w_options + [f"--import-other-from={mvolname}:|:{tarpath}"]
    if options.autoprune:  wyng_cmd.append("--autoprune="+options.autoprune)
    if options.dedup:      wyng_cmd.append("-d")
    p = run(wyng_cmd + ["send"] + volnames, stdout=sys.stdout, stderr=sys.stderr)


elif options.action == "restore":
    ## Restore Qubes VMs with settings

    if not options.session:
        raise ValueError("Please specify a session to restore.")

    backups  = get_qubes_metadata(options.session)
    selected = set(selected or wsessionqubes[options.session]) - set(options.exclude)
    os.chdir(tmpdir)

    # Match VM selections to backed-up volumes
    lvolumes  = []
    templates = [x.name for x in backups.values() if x.klass== "TemplateVM" and x.name in selected]
    appvms    = [x.name for x in backups.values()
                 if x.name not in templates and x.name in selected and x.name != "dom0"]
    if "dom0" in selected:   print("Skipping dom0.")
    for vm in selected - set(templates + appvms):
        if vm in wsessionqubes[options.session]:
            err_out(f"Skipping {vm} (No metadata)")    ; err_domains.append(vm)

    for target in templates + appvms:
        qube = backups[target]

        # Find local qube or create one
        if target in (x.name for x in live_qubes):
            target_qube = live_qubes[target]
            if target_qube.klass != qube.klass:
                err_out("Class mismatch %s vs %s for qube named '%s'."
                        % (target_qube.klass, qube.klass, qube.name))
                err_domains.append(qube.name)
            elif not target_qube.is_halted():
                target_qube.kill()
        else:
            target_qube = qdaemon.add_new_vm(qube.klass, label=qube.label, name=target,
                                             template=qube.template)

        target_qube.tags.add("restore_incomplete")
        lvolumes.append("vm-"+target+"-private") ####
        if target in templates:   lvolumes.append("vm-"+target+"-root") ####

    if not options.unattended:
        print("Warning:  Restoring to existing VMs will overwrite them.")
        if input("Continue [y/N]? ").lower() not in ("y","yes"):   sys.exit(0)

    # Restore data volumes
    #Enh: allow restoring incomplete set of data
    wyng_cmd = w_options + ["-u", "--sparse-write",
                "--session="+options.session, "receive"] + lvolumes + options.volume
    p = run(wyng_cmd, text=True, check=False, stderr=subprocess.PIPE)
    if p.returncode == 2:
        handle_wyng_vol_error(p)
    elif p.returncode > 0:
        raise subprocess.CalledProcessError(p.returncode, p.stderr)

    # Selectively restore qube properties
    # Remove or reset properties that are not in the backup metadata
    for target in templates + appvms:
        qube = backups[target]    ; target_qube = live_qubes[target]
        subdir = "vm-templates/" if qube.klass == "TemplateVM" else "appvms/"

        if exists(subdir+qube.name+"/"+fwfile):
            shutil.copyfile(subdir+qube.name+"/"+fwfile, qubesvar+subdir+target+"/"+fwfile)
        elif exists(qubesvar+subdir+target+"/"+fwfile):
            os.remove(qubesvar+subdir+target+"/"+fwfile)

        for prop in set(qube.properties) | set(target_qube.property_list()):
            if prop in ("dispid","installed_by_rpm","default_dispvm","qid","uuid","xid","klass",
                        "template","name","label","backup_timestamp","ip","ip6",
                        "stubdom_mem","stubdom_xid"):
                continue

            if prop in qube.properties:
                pval = qube.properties[prop]
                try:
                    setattr(target_qube, prop, pval)
                except Exception as err:
                    print("Error setting %s.%s to %s: %s" % (qube.name, prop, pval, err))
                    err_domains.append(qube.name)
            else:
                propdef = target_qube.property_get_default(prop)
                try:
                    setattr(target_qube, prop, propdef)
                except Exception as err:
                    if "cannot be set" not in repr(err):
                        print("Error:", prop, propdef)   ; err_domains.append(qube.name)

        for prop, pval in qube.features.items():   target_qube.features[prop] = pval
        for prop in (x for x in target_qube.features if x not in qube.features):
            del(target_qube.features[prop])

        for bus in target_qube.devices:
            busobj  = target_qube.devices[bus]
            devlist = list(busobj.assignments())
            for dev in devlist:   busobj.detach(dev)
        for bus in qube.devices:
            for backend_domain, ident in qube.devices[bus]:
                options = qube.devices[bus][(backend_domain, ident)]
                assignment = qubesadmin.devices.DeviceAssignment(backend_domain=backend_domain,
                                                    ident=ident, options=options, persistent=True)
                try:
                    target_qube.devices[bus].attach(assignment)
                except Exception as err:
                    print("Error attaching device %s:%s to %s: %s" % (bus,ident,qube.name,err))
                    err_domains.append(qube.name)

        for tag in qube.tags:   target_qube.tags.add(tag)
        for tag in (x for x in target_qube.tags if x not in qube.tags):
            target_qube.tags.remove(tag)

        if "restore_incomplete" in target_qube.tags and target not in err_domains:
            target_qube.tags.remove("restore_incomplete")


elif options.action == "verify":
    assert options.session
    backups  = get_qubes_metadata(options.session)
    selected = set(selected or wsessionqubes[options.session]) - set(options.exclude)
    if not selected:   x_it(1, "No matching contents")

    lvolumes = [f"vm-{vm}-{suffix}" for vm,ses_d in qube_wvolmap.items() ####
                                        for ses,suflst in ses_d.items() for suffix in suflst
                                        if vm in selected and ses==options.session]

    wyng_cmd = w_options + ["--session="+options.session, "verify"] \
             + [mvolname] + lvolumes + options.volume
    p = run(wyng_cmd, text=True, check=False, stderr=subprocess.PIPE)
    if p.returncode == 2:
        handle_wyng_vol_error(p)
    elif p.returncode > 0:
        raise CalledProcessError(p.stderr)

    for vm in selected:
        if vm not in backups.keys():
            err_out(f"No settings metadata for qube {vm}.")    ; err_domains.append(vm)


elif options.action == "prune":
    assert options.session or options.autoprune and not options.exclude
    #Enh: pass exclude vols to wyng --volex

    lvolumes = [] if not selected else [f"vm-{vm}-{suffix}" for vm,ses_d in qube_wvolmap.items() 
                                        for ses,suflst in ses_d.items() for suffix in suflst
                                        if vm in selected and ses==options.session]

    if not options.unattended:
        print("Warning:  Data cannot be recovered after deleting it from the archive.")
        if input("Continue [y/N]? ").lower() not in ("y","yes"):   sys.exit(0)

    wyng_cmd = w_options + ["-u"]
    if options.session: wyng_cmd.append("--session="+options.session)
    if options.allbefore: wyng_cmd.append("--all-before")
    if options.autoprune: wyng_cmd.append("--autoprune="+options.autoprune)
    run(wyng_cmd + ["prune"] + lvolumes + options.volume, text=True, stderr=subprocess.PIPE)


elif options.action == "delete":
    assert len(selected) == 1
    lvolumes = [f"vm-{vm}-{suffix}" for vm,ses_d in qube_wvolmap.items() 
                                        for ses,suflst in ses_d.items() for suffix in suflst
                                        if vm in selected]

    if not options.unattended:
        print("Warning:  Data cannot be recovered after deleting it from the archive.")
        if input("Continue [y/N]? ").lower() not in ("y","yes"):   sys.exit(0)

    for vol in lvolumes + options.volume:
        wyng_cmd = w_options + ["-u", "delete", vol]
        run(wyng_cmd)


elif options.action == "list":
    if not options.pool_info:   print("URL", arch_mdata["url"])

    if options.pool_info:
        print_pools()

    elif options.session:
        print("\nQubes in session", options.session+":")
        for qube in wsessionqubes[options.session]:
            flag = "*" if mvolname not in wvolsessionmap[options.session] else ""
            print(" ", qube, flag)

    elif selected:
        for qube in selected:
            print("\nSessions with qube "+qube+":")
            print("  ".join(sorted((x for x,y in wsessionqubes.items()
                                    if qube in y and mvolname in wvolsessionmap[x])
                  )))
            print()
    else:
        print("\nArchived sessions:")
        print("  ".join((x for x in sorted(wsessionqubes) if mvolname in wvolsessionmap[x])
              ))


# Cleanup
if err_domains:   x_it(2, "\nErrors for VMs: "+" ".join(err_domains))
