#!/usr/bin/env python3
# editor width: 100   -----------------------------------------------------------------------------

###  wyng-util-qubes
###  Copyright Christopher Laprise 2024 / tasket@protonmail.com
###  Licensed under GNU General Public License v3. See file 'LICENSE'.

print("wyng-util-qubes v0.9wip rel 20240414")

import qubesadmin, sys, os, shutil, subprocess, argparse, json, tempfile
from qubesadmin.backup.core3 import Core3Qubes

exists  = os.path.exists

def b2i(b):   return int.from_bytes(b, byteorder="big")

def err_out(text):   sys.stderr.write(text+"\n")

# Exit with simple message
def x_it(code, text):
    err_out("Error: "+text)
    #cleanup()
    shutil.rmtree(tmpdir, ignore_errors=True)
    sys.exit(code)


class QubesPool:
    def __init__(self, qobj, path):
        self.name = qobj.name    ; self.driver = qobj.driver    ; self.config = qobj.config
        self.path = path         ; self.qobj   = qobj


# Get Qubes storage pools
def get_pools():
    pools = {}
    for qpool in qadmin.pools.values():
        if qpool.driver == "lvm_thin":
            path = (qpool.config['volume_group'], qpool.config['thin_pool'])
        elif qpool.driver == "file-reflink":
            path = (qpool.config["dir_path"], )
        else:
            continue
        pools[qpool.name] = QubesPool(qpool, path)
    return pools


def print_pools():
    print("\nQubes local storage pools:")
    for pname, pool in qpools_d.items():
        print(f" {pool.name:<24}: {pool.driver:<12}, {pool.path}")


# Get archive directory
def get_wyng_directory():
    # Parse full vol/session list into lookup tables...
    # wvolsessionmap:  (dict)session -> arch_vol_name
    # wsessionqubes :  (dict)session -> qube_name
    # wvolumemap    :  (dict)arch_vol_name -> (list)sessions
    # qube_wvolmap  :  (dict)qube_name -> (dict)session -> (set)arch_vol_name
    # q_wvoltypemap :  (dict)qube_name -> (dict)voltype -> arch_vol_name

    wvolsessionmap, wvolumemap, qube_wvolmap, q_wpriv_wrootmap = {}, {}, {}, {}
    volname  = qubename = None
    wyng_cmd = w_options + ["--json", "list"]
    jdata = json.loads((j := run(wyng_cmd, text=True).stdout)[j.find("{"):])

    for volname, sname in ((vk,sk) for vk,vv in jdata["volumes"].items() for sk in vv["sessions"]):
        wvolumemap.setdefault(volname, list()).append(sname[2:])
        wvolsessionmap.setdefault(sname[2:], set()).add(volname)

    wsessionqubes = {}
    for ses,vols in wvolsessionmap.items():
        if s := set((get_qubename_parts(x)[1] for x in vols
                     if x.endswith(("-root","-private","/root.img","/private.img")))):
            wsessionqubes[ses] = s

    # make qube_wvolmap...
    for vol, ses in ((x,s) for x,y in wvolumemap.items() for s in y
                     if x.startswith(("vm-","appvms/","vm-templates/"))):
        prefix, qubename, suffix = get_qubename_parts(vol)
        qube_wvolmap.setdefault(qubename, dict()).setdefault(ses, set()).add(vol)
        if vol.endswith(("-root","/root.img")):
            voltype = "root"
        elif vol.endswith(("-private","/private.img")):
            voltype = "private"
        else:
            continue
        q_wpriv_wrootmap.setdefault(qubename, {}).setdefault(ses,{})[voltype] = vol

    return jdata, wvolsessionmap, wvolumemap, wsessionqubes, qube_wvolmap, q_wpriv_wrootmap


def get_qubes_metadata(session):
    # Receive metadata
    wyng_cmd = w_options + ["-u", "--quiet",
                            "--save-to="+tarpath, "--session="+session, "receive", mvolname]
    result = run(wyng_cmd, check=True)

    #Enh: get archive listing and check volume presence vs selected qube list
    result = run(["tar", "-xzf", tarpath], cwd=tmpdir, check=True)
    return Core3Qubes(tmpdir+"/"+qubesxml).domains


def get_vm_volname(vmname, voltype="private"):
    assert voltype in ("private","root") #### and conv in ("rlnk","tlvm","")
    vm  = live_qubes[vmname]           ; vol = vm.volumes[voltype]
    pt  = qpools_d[vol.pool].driver    ; template = vm.klass == "TemplateVM"

    if pt == "file-reflink":
        vname = vm.volumes[voltype].vid + ".img"
    elif pt == "lvm_thin":
        vname = f"vm-{vm.name}-{voltype}"
                  #f'{"vm-templates" if template else "appvms"}/{vm.name}/{voltype}.img' \
                  #if conv=="rlnk" else "")
    return vname


def get_qubename_parts(n):
    if n.startswith("vm-") and n.endswith(("-root","-private")):
        return ["vm"] + n.partition("vm-")[-1].rsplit("-",maxsplit=1)
    elif n.startswith(("appvms/","vm-templates/")) and n.endswith(("/root.img","/private.img")):
        return ((t := n.split("/"))[0], "/".join(t[1:-1]), t[-1])
    else:
        return "","",""


def convert_volname(n, to_pooltype, template):
    p = get_qubename_parts(n)
    if to_pooltype == "file-reflink":
        assert n.startswith("vm-")
        n = f'{"vm-templates" if template else "appvms"}/{p[1]}/{p[2].removesuffix(".img")}.img'
    elif to_pooltype == "lvm_thin":
        assert n.startswith("vm-templates") or not template
        n = f'vm-{p[1]}-{p[2].removesuffix(".img")}'
    return (n, template, to_pooltype)


def list_sessions(slist):
    rows, extra = divmod(size := len(slist), c := columns)   ; rows += bool(extra)
    if extra and rows < 3 and (columns - extra) > 1:   c -= (columns - extra) // 2
    for r in range(rows):
        print("  ".join(sorted(slist[x*rows+r][2:] for x in range(c) if x*rows+r < size)))


def handle_wyng_vol_error(p):
    errln = [x.partition("volumes(s)") for x in p.stdout.splitlines() if "volumes(s):" in x]
    err_domains.extend(errln.split())
    err_out("(Wyng) "+"".join(errln))


def run(cmd, check=True, capt=True, **kwargs):
    capt   = capt and not ("stderr" in kwargs or "stout" in kwargs)
    result = subprocess.run(cmd, capture_output=capt, **kwargs)
    if check and result.returncode:
        if capt:   err_out(f"{result.stdout or ''}\n{result.stderr or ''}")
        sys.exit(result.returncode)
    return result



##  MAIN  ##

if sys.hexversion < 0x3080000:
    err_out("Python ver. 3.8 or greater required."); sys.exit(1)

# Root user required
if os.getuid() > 0:
    err_out("Must be root user."); sys.exit(1)


# Parse Arguments

parser = argparse.ArgumentParser(description="")
parser.add_argument("action", choices=("backup","restore","verify","prune","delete","list"),
                    help="Action to take")
parser.add_argument("--authmin", help="Minutes to remember authentication.")
parser.add_argument("--session", help="YYYYMMDD-HHMMSS[,YYYYMMDD-HHMMSS]"
                                 " select session date, singular or range.")
parser.add_argument("--dedup", "-d", action="store_true", default=False,
                    help="Data deduplication. (backup)")
parser.add_argument("--includes", "-i", action="store_true", default=False,
                    help="Select VMs marked 'include in backups' (backup)")
parser.add_argument("--exclude", action="append", default=[],
                    help="VM name to exclude. (backup)")
parser.add_argument("--autoprune", default=None,
                    help="Automatic pruning: off/on/full. (backup, prune)")
parser.add_argument("--all-before", dest="allbefore", action="store_true", default=False,
                    help="Select all sessions before --session date-time.")
parser.add_argument("--all", action="store_true", default=False, help="List all VMs and sessions")
parser.add_argument("--pool-info", action="store_true", default=False,
                    help="Show local disk storage (list)")
parser.add_argument("--pool", "-p", default=None,
                    help="Specify Qubes storage pool for creating VMs (restore).")
parser.add_argument("--local", help="Deprecated: Use --pool")
parser.add_argument("--dest",  help="URL location of archive.")
parser.add_argument("-w", dest="wyngopt", action="append", default=[],
                    help="Pass an option to Wyng directly.")
parser.add_argument("--include-disposable", action="store_true", default=False,
                    help="Include disposable VMs (experimental)")
parser.add_argument("--unattended", "-u", action="store_true", default=False,
                    help="Unattended operation")
parser.add_argument("--meta-dir", dest="metadir", default="", help="Use alternate metadata path.")
parser.add_argument("qubenames", nargs="*")
options = parser.parse_args()    ; options.action = options.action.lower()
options.unattended = options.unattended or not sys.stdin.isatty()


## CONSTANTS / GLOBALS ##

columns    = max(4, min(10, shutil.get_terminal_size().columns // 17))
thispath   = os.path.dirname(__file__) ; mvolname   = "wyng-qubes-metadata"
wyngcmd    = thispath+"/wyng" if exists(thispath+"/wyng") else "wyng"
tmpdir_obj = tempfile.TemporaryDirectory(dir="/tmp", prefix="wuq")
tmpdir     = tmpdir_obj.name           ; tarpath    = tmpdir+"/qmeta.tgz"
qubesvar   = "/var/lib/qubes/"         ; qubesxml   = "qubes.xml"    ; fwfile = "firewall.xml"
qadmin     = qubesadmin.Qubes()        ; qdaemon    = qadmin.app     ; live_qubes = qdaemon.domains
selected   = options.qubenames         ; err_domains= []

if os.path.exists(tmpdir):   shutil.rmtree(tmpdir)
os.makedirs(tmpdir)

w_options = [wyngcmd]    ; qpools_d  = get_pools()
if options.dest:
    w_options.append("--dest="+options.dest)
if options.local:   x_it(1, "Please use --pool instead of --local")
if options.metadir:    w_options.append("--meta-dir="+options.metadir)
if options.unattended: w_options.append("-u")
if options.authmin:    w_options.append("--authmin="+options.authmin)
if options.all and options.action != "list":
    x_it(1, "--all may only be used with 'list'.")
w_options.extend(["--"+x for x in options.wyngopt])


if not (options.action == "list" and options.pool_info):
    arch_mdata, wvolsessionmap, wvolumemap, wsessionqubes, qube_wvolmap, q_wpriv_wrootmap \
        = get_wyng_directory()


# Process Actions
if options.action == "backup":

    pool_vols = {}
    includes  = [x.name for x in live_qubes if x.include_in_backups and options.includes]
    for vmname in sorted(set(selected+includes)):
        vm = live_qubes[vmname]
        if vmname in ("dom0","default-mgmt-dvm") or vmname not in live_qubes \
        or vmname in options.exclude:
            print("Skipping", vmname)    ; continue
        if vm.klass == "DispVM" and not options.include_disposable:
            print("Skipping DispVM", vmname)    ; continue

        for ii in ("private","root"):
            if ii == "root" and vm.klass not in ("TemplateVM","StandaloneVM"):   continue
            # Create a dict of {pool.pathname: [volnames]}
            pool_vols.setdefault("/".join(qpools_d[vm.volumes[ii].pool].path), []).append(
                                 (get_vm_volname(vmname, ii), "")  )

    if not pool_vols:   x_it(1, "Please supply a list of Qubes VMs to backup.")

    # Copy the Qubes metadata to a .tar
    os.chdir(qubesvar)
    run("find . -name '*.xml' | tar -czf " +tarpath+ " --verbatim-files-from -T -", shell=True)

    # Start Wyng backup with selected VM volumes and import of the metadata tar
    json.dump(pool_vols, open(jsontmp := tmpdir+"/wuq_vols.lst", "w"))
    w_options.append("--local-from=" + jsontmp)
    wyng_cmd = w_options + [f"--import-other-from={mvolname}:|:{tarpath}"]
    if options.autoprune:  wyng_cmd.append("--autoprune="+options.autoprune)
    if options.dedup:      wyng_cmd.append("-d")

    p = run(wyng_cmd + ["send"], stdout=sys.stdout, stderr=sys.stderr)


elif options.action == "restore":
    ## Restore Qubes VMs with settings

    if not (session := options.session):
        if len(selected) == 1:
            session = sorted(qube_wvolmap[selected[0]].keys())[-1]
        else:
            raise ValueError("Please specify either a --session or a single qube name to restore.")

    backups  = get_qubes_metadata(session)   ; pool_vols  = {}
    selected = set(selected or wsessionqubes[session]) - set(options.exclude)
    os.chdir(tmpdir)

    # Match VM selections to backed-up volumes
    templates = [x.name for x in backups.values() if x.klass== "TemplateVM" and x.name in selected]
    appvms    = [x.name for x in backups.values()
                 if x.name not in templates and x.name in selected and x.name != "dom0"]
    if "dom0" in selected:   print("Skipping dom0.")
    for vm in selected - set(templates + appvms):
        if vm in wsessionqubes[session]:
            err_out(f"Skipping {vm} (No metadata)")    ; err_domains.append(vm)

    for target in templates + appvms:
        qube = backups[target]

        # Find local qube or create one
        if target in (x.name for x in live_qubes):
            vm = live_qubes[target]    ; vmklass = vm.klass
            if not vm.is_halted():   vm.kill()
            if vmklass != qube.klass:
                vm.tags.add("restore_incomplete")
                try:
                    del(live_qubes[vm.name])
                except:
                    err_out("Class mismatch %s vs %s for qube named '%s'."
                            % (vmklass, qube.klass, qube.name))
                    err_domains.append(qube.name)
                    continue

        if target not in (x.name for x in live_qubes):
            vm = qdaemon.add_new_vm(qube.klass, label=qube.label, name=target,
                                    template=qube.template, pool=options.pool)
            vm.tags.add("restore_incomplete")

        for ii in ("private","root"):
            if ii == "root" and vm.klass not in ("TemplateVM","StandaloneVM"):   continue
            # Create a dict of {pool.pathname: [(volname, alias), ...]}
            pool_vols.setdefault("/".join(qpools_d[vm.volumes[ii].pool].path), []).append(
                                 (q_wpriv_wrootmap[target][session][ii],
                                  get_vm_volname(target, ii))  )

    if not options.unattended:
        print("Warning:  Restoring to existing VMs will overwrite them.")
        if input("Continue [y/N]? ").lower() not in ("y","yes"):   sys.exit(0)

    # Restore data volumes
    json.dump(pool_vols, open(jsontmp := tmpdir+"/wuq_vols.lst", "w"))
    wyng_cmd = w_options + ["-u", "--sparse-write", "--local-from="+jsontmp,
                "--session="+session, "receive"]
    p = run(wyng_cmd, text=True, check=False, stderr=subprocess.PIPE)
    if p.returncode == 2:
        handle_wyng_vol_error(p)
    elif p.returncode > 0:
        raise subprocess.CalledProcessError(p.returncode, p.stderr)

    # Selectively restore qube properties
    # Remove or reset properties that are not in the backup metadata
    for target in templates + appvms:
        qube = backups[target]    ; vm = live_qubes[target]
        vm.tags.add("restore_incomplete")
        subdir = "vm-templates/" if qube.klass == "TemplateVM" else "appvms/"

        if exists(subdir+qube.name+"/"+fwfile):
            shutil.copyfile(subdir+qube.name+"/"+fwfile, qubesvar+subdir+target+"/"+fwfile)
        elif exists(qubesvar+subdir+target+"/"+fwfile):
            os.remove(qubesvar+subdir+target+"/"+fwfile)

        for prop in set(qube.properties) | set(vm.property_list()):
            if prop in ("dispid","installed_by_rpm","default_dispvm","qid","uuid","xid","klass",
                        "template","name","label","backup_timestamp","ip","ip6",
                        "stubdom_mem","stubdom_xid"):
                continue

            if prop in qube.properties:
                pval = qube.properties[prop]
                try:
                    setattr(vm, prop, pval)
                except Exception as err:
                    print("Error setting %s.%s to %s: %s" % (qube.name, prop, pval, err))
                    err_domains.append(qube.name)
            else:
                propdef = vm.property_get_default(prop)
                try:
                    setattr(vm, prop, propdef)
                except Exception as err:
                    if "cannot be set" not in repr(err):
                        print("Error:", prop, propdef)   ; err_domains.append(qube.name)

        for prop, pval in qube.features.items():   vm.features[prop] = pval
        for prop in (x for x in vm.features if x not in qube.features):
            del(vm.features[prop])

        for bus in vm.devices:
            busobj  = vm.devices[bus]
            devlist = list(busobj.assignments())
            for dev in devlist:   busobj.detach(dev)
        for bus in qube.devices:
            for backend_domain, ident in qube.devices[bus]:
                options = qube.devices[bus][(backend_domain, ident)]
                assignment = qubesadmin.devices.DeviceAssignment(backend_domain=backend_domain,
                                                    ident=ident, options=options, persistent=True)
                try:
                    vm.devices[bus].attach(assignment)
                except Exception as err:
                    print("Error attaching device %s:%s to %s: %s" % (bus,ident,qube.name,err))
                    err_domains.append(qube.name)

        for tag in qube.tags:   vm.tags.add(tag)
        for tag in (x for x in vm.tags if x not in qube.tags):
            vm.tags.remove(tag)

        if "restore_incomplete" in vm.tags and target not in err_domains:
            vm.tags.remove("restore_incomplete")


elif options.action == "verify":
    if not (session := options.session):
        if len(selected) == 1:
            session = sorted(qube_wvolmap[selected[0]].keys())[-1]
        else:
            raise ValueError("Please specify either a --session or a single qube name to verify.")

    backups  = get_qubes_metadata(session)
    selected = set(selected or wsessionqubes[session]) - set(options.exclude)
    if not selected:   x_it(1, "No matching contents")

    lvolumes = [vol for vm,ses_d in qube_wvolmap.items()
                        for ses,vlst in ses_d.items() for vol in vlst
                        if vm in selected and ses==session]

    wyng_cmd = w_options + ["--session="+session, "verify"] \
             + [mvolname] + lvolumes
    p = run(wyng_cmd, text=True, check=False, stderr=subprocess.PIPE)
    if p.returncode == 2:
        handle_wyng_vol_error(p)
    elif p.returncode > 0:
        raise CalledProcessError(p.stderr)

    for vm in selected:
        if vm not in backups.keys():
            err_out(f"No settings metadata for qube {vm}.")    ; err_domains.append(vm)


elif options.action == "prune":
    assert options.session or options.autoprune and not options.exclude
    #Enh: pass exclude vols to wyng --volex

    lvolumes = [vol for vm,ses_d in qube_wvolmap.items()
                        for ses,vlst in ses_d.items() for vol in vlst
                        if vm in selected and ses==options.session]

    if not options.unattended:
        print("Warning:  Data cannot be recovered after deleting it from the archive.")
        if input("Continue [y/N]? ").lower() not in ("y","yes"):   sys.exit(0)

    wyng_cmd = w_options + ["-u"]
    if options.session: wyng_cmd.append("--session="+options.session)
    if options.allbefore: wyng_cmd.append("--all-before")
    if options.autoprune: wyng_cmd.append("--autoprune="+options.autoprune)
    run(wyng_cmd + ["prune"] + lvolumes, text=True, stderr=subprocess.PIPE)


elif options.action == "delete":
    assert len(selected) == 1
    lvolumes = [vol for vm,ses_d in qube_wvolmap.items()
                        for ses,vlst in ses_d.items() for vol in vlst
                        if vm in selected]

    if not options.unattended:
        print("Warning:  Data cannot be recovered after deleting it from the archive.")
        if input("Continue [y/N]? ").lower() not in ("y","yes"):   sys.exit(0)

    for vol in lvolumes:
        wyng_cmd = w_options + ["-u", "delete", vol]
        run(wyng_cmd)


elif options.action == "list":
    if not options.pool_info:   print("URL", arch_mdata["url"])
    if options.all:   selected = list(qube_wvolmap)

    if options.pool_info:
        print_pools()

    elif selected:
        for qube, seslist in qube_wvolmap.items():
            xml_seslist = [x for x in seslist if mvolname in wvolsessionmap[x]
                                              and qube in selected]
            if not xml_seslist:   continue
            print(f"\n{qube}:")
            if options.unattended:
                for ses in sorted(xml_seslist):   print(ses)
            else:
                list_sessions(xml_seslist)

    elif options.session:
        print("\nQubes in session", options.session+":")
        for qube in wsessionqubes[options.session]:
            flag = "*" if mvolname not in wvolsessionmap[options.session] else ""
            print(" ", qube, flag)

    else:
        print("\n* Archived Qubes VMs *")
        print("\nLatest:           VM Name:")
        for qube, seslist in qube_wvolmap.items():
            xml_seslist = [x for x in seslist if mvolname in wvolsessionmap[x]]
            if not xml_seslist:   continue
            print(sorted(xml_seslist)[-1], " ", qube)


# Cleanup
if err_domains:   x_it(2, "\nErrors for VMs: "+" ".join(err_domains))
