#!/usr/bin/env python3

###  wyng-util-qubes
###  Copyright Christopher Laprise 2023 / tasket@protonmail.com
###  Licensed under GNU General Public License v3. See file 'LICENSE'.


import qubesadmin, sys, os, shutil, subprocess
from qubesadmin.backup.core3 import Core3Qubes

b2i     = lambda b: int.from_bytes(b, byteorder="big")
exists  = os.path.exists

# Exit with simple message
def x_it(code, text):
    sys.stderr.write(text+"\n")
    #cleanup()
    sys.exit(code)


print("wyng-util-qubes v0.1beta rel 20230120")

if len(sys.argv) < 3 or sys.argv[1].lower() not in ("backup","restore"):
    x_it(1, "Usage:\n"
            "wyng-util-qubes backup <qube_name [qube_name...]>\n"
            "wyng-util-qubes restore <qube_name [qube_name...]>")

if sys.hexversion < 0x3080000:
    x_it(1, "Python ver. 3.8 or greater required.")

# Root user required
if os.getuid() > 0:
    x_it(1, "Must be root user.")


## CONSTANTS ##

lvmvolgrp  = "qubes_dom0"                ; lvmpool  = "vm-pool"      ; lvmode   = True
mvolname   = "wyng-qubes-metadata"       ; mvolpath = "/dev/"+lvmvolgrp+"/"+mvolname
qubesvar   = "/var/lib/qubes/"           ; qubesxml = "qubes.xml"    ; fwfile   = "firewall.xml"
tmpdir     = "/tmp/wyng-util-qubes"      ; tarpath  = tmpdir+"/qmeta.tgz"
selected   = sys.argv[2:]                ; err_domains = []
qdaemon = qubesadmin.Qubes().app         ; live_qubes = qdaemon.domains   

if os.path.exists(tmpdir):   shutil.rmtree(tmpdir)
os.makedirs(tmpdir)

if sys.argv[1].lower() == "backup":

    vols = []
    for vm in (x for x in selected if x in live_qubes):
        if vm == "dom0":
            print("Skipping dom0.")
            continue
        vols.append("vm-"+vm+"-private")
        if "template" not in live_qubes[vm].property_list():   vols.append("vm-"+vm+"-root")

    #Enh: Use include_in_backups property
    if not vols:   raise ValueError("Please supply a list of Qubes VMs to backup.")

    ## Copy the Qubes metadata volume and add it to Wyng archive
    os.chdir(qubesvar)
    subprocess.run(["tar", "-czf", tarpath, "--exclude=*img", "qubes.xml",
                    "appvms", "vm-templates"], check=True)
    tarsize = os.path.getsize(tarpath)

    ## Initialize metadata volume
    if lvmode:
        if os.path.exists(mvolpath):
            subprocess.run(["lvm", "lvremove", "-q", "-f", mvolpath], check=True)

        subprocess.run(["lvm", "lvcreate", "-q", "-prw", "-ay", "-kn",
                        "-V", str(tarsize//1024+1)+"K", "--thin",
                        "-n", mvolname, lvmvolgrp+"/"+lvmpool], check=True)

        subprocess.run(["dd", "if="+tarpath, "of="+mvolpath, "status=none"], check=True)
    else:
        raise NotImplementedError()
        #cp tarpath ???

    wyng_cmd = ["wyng", "-u", "send", mvolname] + vols
    subprocess.run(wyng_cmd, check=True)


elif sys.argv[1].lower() == "restore":
    ## Restore Qubes VMs with settings

    if not selected:   raise ValueError("Please supply a list of Qubes VMs to restore.")

    wyng_cmd = ["wyng", "-u", "--quiet", "receive", mvolname]
    subprocess.run(wyng_cmd, check=True)
    if not os.path.exists(mvolpath):   raise RuntimeError(mvolpath+" not found.")

    os.chdir(tmpdir)
    subprocess.run(["tar", "-xzf", mvolpath], check=True)
    backups = Core3Qubes(tmpdir+"/"+qubesxml).domains

    templates = [x for x in backups.values() if x.klass == "TemplateVM"]
    for qube in templates + [x for x in backups.values() if x not in templates]:
        target = qube.name
        if target not in selected:   continue
        if target == "dom0":
            print("Skipping dom0.")
            continue

        # Find local qube or create one
        if target in (x.name for x in live_qubes):
            target_qube = live_qubes[target]
            if not target_qube.is_halted():   target_qube.kill()
        else:
            target_qube = qdaemon.add_new_vm(qube.klass, label=qube.label, name=target,
                                             template=qube.template)


        # Restore private volume
        subprocess.run(["wyng", "-u", "--quiet", "--sparse-write",
                        "receive", "vm-"+target+"-private"], check=True)
        if qube.template is None:
            # Restore template or standalone root volume
            subprocess.run(["wyng", "-u", "--quiet", "--sparse-write",
                            "receive", "vm-"+target+"-root"], check=True)


        # Selectively restore qube properties
        # Remove or reset properties that are not in the backup metadata

        subdir = "vm-templates/" if qube.klass == "TemplateVM" else "appvms/"
        for prop in set(qube.properties) | set(target_qube.property_list()):
            if prop in ("dispid","installed_by_rpm","default_dispvm","qid","uuid","xid","klass",
                        "template","name","label","backup_timestamp","stubdom_mem","stubdom_xid"):
                continue

            if prop in qube.properties:
                pval = qube.properties[prop]
                try:
                    setattr(target_qube, prop, pval)
                except Exception as err:
                    print("Error setting %s.%s to %s: %s" % (qube.name, prop, pval, err))
                    err_domains.append((qube.name, target))
            elif prop not in ("label","name","template"):
                try:
                    setattr(target_qube, prop, target_qube.property_get_default(prop))
                except Exception as err:
                    if "cannot be set" not in repr(err):
                        print(err)   ; err_domains.append((qube.name, target))

        for prop, pval in qube.features.items():   target_qube.features[prop] = pval
        for prop in (x for x in target_qube.features if x not in qube.features):
            del(target_qube.features[prop])

        for tag in qube.tags:   target_qube.tags.add(tag)
        for tag in (x for x in target_qube.tags if x not in qube.tags):
            target_qube.tags.remove(tag)

        for bus in target_qube.devices:
            busobj  = target_qube.devices[bus]
            devlist = list(busobj.assignments())
            for dev in devlist:   busobj.detach(dev)
        for bus in qube.devices:
            for backend_domain, ident in qube.devices[bus]:
                options = qube.devices[bus][(backend_domain, ident)]
                assignment = qubesadmin.devices.DeviceAssignment(backend_domain=backend_domain,
                                                    ident=ident, options=options, persistent=True)
                try:
                    target_qube.devices[bus].attach(assignment)
                except Exception as err:
                    print("Error attaching device %s:%s to %s: %s" % (bus,ident,qube.name,err))
                    err_domains.append((qube.name, target))

        if exists(subdir+qube.name+"/"+fwfile):
            shutil.copyfile(subdir+qube.name+"/"+fwfile, qubesvar+subdir+target+"/"+fwfile)
        elif exists(qubesvar+subdir+target+"/"+fwfile):
            os.remove(qubesvar+subdir+target+"/"+fwfile)


else:
    print("Specify 'backup' or 'restore'.")
